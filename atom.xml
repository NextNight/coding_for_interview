<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[不以刷题为目的的面试不是个好程序员]]></title>
  <link href="http://atlasbl.cn/coding_for_interview/atom.xml" rel="self"/>
  <link href="http://atlasbl.cn/coding_for_interview/"/>
  <updated>2019-03-08T17:23:21+08:00</updated>
  <id>http://atlasbl.cn/coding_for_interview/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[数据结构]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15510643590406.html"/>
    <updated>2019-02-25T11:12:39+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15510643590406.html</id>
    <content type="html"><![CDATA[
<p>数据结构：是一中存储和组织数据的方式，选择合适的数据结构对于各种数据操作的效率有很大的提升。以下是常用的数据结构及相关的关系<br/>
<img src="media/15510643590406/15510705984151.jpg" alt="" style="width:780px;"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[数组：Array]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15391804069666.html"/>
    <updated>2018-10-10T22:06:46+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15391804069666.html</id>
    <content type="html"><![CDATA[
<p>在计算器科学中，数组数据结构（英语：array data structure），简称数组（英语：Array），是由_相同类型_的元素（element）的集合所组成的数据结构，「_分配一块连续的内存来存储_」。利用元素的索引（index）可以计算出该元素对应的存储地址。</p>

<p>最简单的数据结构类型是一维数组。例如，索引为0到9的32位整数数组，可作为在存储器地址2000，2004，2008，...2036中，存储10个变量，因此索引为i的元素即在存储器中的2000+4×i地址。数组第一个元素的存储器地址称为第一地址或基础地址。<br/>
<img src="media/15391804069666/15501317583804.jpg" alt="" style="width:815px;"/><br/>
同样可以得到二维数组a[m][n],(m行n列)的寻址公式：a[i][j] = startaddress+(i·n+j)*type_size</p>

<h2 id="toc_0">数组的特点</h2>

<ul>
<li>连续的内存：存储地址连续</li>
<li>同一类型：一个数组内只能存储统一数据类型的数据</li>
<li>相同大小：相同类型则大小相同</li>
<li>随机访问：可直接根据下标得到存储地址访问到数据</li>
<li>插入删除耗时：插入和删除为了保证空间的连续性，需要不断的进行数据的移动。</li>
<li>初始化必须知道大小：因为需要分配连续的空间</li>
<li>扩容消耗时间，空间：扩容时需要进行数据的copy，索引尽量减少扩容操作，需要多大的空间就申请多大的空间。避免多次的扩容操作。</li>
</ul>

<h2 id="toc_1">数组应用</h2>

<ul>
<li>实现List：List这种数据结构就是通过数组实现的</li>
<li>实现String：字符串这种数据结构就是通过字符数组实现的</li>
<li>实现：队列，堆，树，栈。</li>
</ul>

<h2 id="toc_2">数组相关的题目</h2>

<p><a href="15392386512557.html">两数之和</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[链表：LinkedList]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15391807987921.html"/>
    <updated>2018-10-10T22:13:18+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15391807987921.html</id>
    <content type="html"><![CDATA[
<p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。</p>

<p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p>

<h1 id="toc_0">链表的特点</h1>

<ul>
<li>不使用连续的内存</li>
<li>只能顺序访问，不能随机读取</li>
<li>插入，删除简单，查找慢</li>
<li>动态扩展</li>
</ul>

<h1 id="toc_1">常见链表</h1>

<ul>
<li>单向链表</li>
<li>双向链表</li>
<li>循环链表</li>
</ul>

<h1 id="toc_2">链表的实现</h1>

<p>Python List实现链表：</p>

<pre class="line-numbers"><code class="language-python">class Node(object):
    &quot;&quot;&quot;定义链表的节点&quot;&quot;&quot;
    def __init__(self, data):
        self._data = data
        self._next = None

    def get_data(self):
        return self._data

    def get_next(self):
        return self._next

    def set_data(self, data):
        self._data = data

    def set_next(self, next):
        self._next = next

class LinkedList(object):
    def __init__(self):
        self._head = Node(None)
        self._tail = Node(None)
        self._head.set_next(self._tail)
        self._size = 0
        
    def add(self, data):
        &quot;&quot;&quot;头插法：新加入的元素永远在head._next&quot;&quot;&quot;
        node = Node(data)
        node.set_next(self._head.get_next())
        self._head.set_next(node)
        self._size += 1
        
    def remove(self, data):
        &quot;&quot;&quot;删除节点&quot;&quot;&quot;
        prev = self._head
        while prev.get_next() is not self._tail:
            cur = prev.get_next()
            if cur.get_data() == data:
                prev.set_next(cur.get_next())
        self._size -=1
        
    def size(self):
        return self._size
        
    def is_exist(self, data):
        &quot;&quot;&quot;查询某值是否在链表&quot;&quot;&quot;
        if any([self._head.get_next() == self._tail, data == None]):
            return False
        cur = self._head.get_next()
        while cur is not self._tail:
            if cur.get_data == data:
                return True
            else:
                return False
                
    def is_empty(self):
        &quot;&quot;&quot;判断是否为空&quot;&quot;&quot;
        return self._head.get_next() == self._tail
        
    def foreach(self):
        if self._head.get_next() == self._tail:
            return None
        data = []
        cur = self._head.get_next()
        while cur is not self._tail:
            data.append(cur.get_data())
            cur = cur.get_next()
        return data
</code></pre>

<p>因为是自定义实现，使用了固定长度的List来实现，链表的重要操作难度是在删除和添加节点上，</p>

<p><strong>⚠️注意</strong>：<code>Head指针永远不变，是链表的开始</code>，不要直接使用head指针直接去进行指针移动，这样就无法返回操作后的链表了。</p>

<h1 id="toc_3">链表相关的题目</h1>

<p>全部来源于<a href="https://leetcode-cn.com/">Leetcode</a>中文网</p>

<h4 id="toc_4">简单:</h4>

<p><a href="">『删除链表中的节点』</a>,<a href="">『删除链表的倒数第N个节点』</a>,<a href="">『反转链表』</a>,<a href="">『合并两个有序链表』</a>,<a href="">『回文链表』</a>,<a href="">『环形链表』</a>,<a href="">『链表排序』</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[栈：Stack]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392291360952.html"/>
    <updated>2018-10-11T11:38:56+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392291360952.html</id>
    <content type="html"><![CDATA[
<p>栈（英语：stack）又称为栈或堆叠，是计算机科学中一种特殊的串列形式的抽象数据类型，其特殊之处在于只能允许在链表或数组的一端（称为堆栈顶端指针，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算。另外栈也可以用一维数组或链表的形式来完成。堆栈的另外一个相对的操作方式称为队列。</p>

<p>由于堆栈数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作</p>

<h1 id="toc_0">栈的操作</h1>

<p>堆栈数据结构使用两种基本操作：推入（压栈，push）和弹出（弹栈，pop）：</p>

<ul>
<li>推入：将数据放入堆栈的顶端（数组形式或串列形式），堆栈顶端top指针加一。</li>
<li>弹出：将顶端数据数据输出（回传），堆栈顶端数据减一。</li>
</ul>

<h1 id="toc_1">栈的实现</h1>

<ul>
<li>栈可以用数组实现(顺序栈）：需要面对动态扩容的问题，最坏的情况是扩容数组需要O（n）时间复杂度。</li>
</ul>

<pre class="line-numbers"><code class="language-python">class Stack(object):
    &#39;&#39;&#39;数组实现&#39;&#39;&#39;
    def __init__(self, init_size):
        self._data = [0] * init_size
        self._top = 0
        self._size = init_size

    def isempty(self):
        return self._top==0

    def push(self, item):
        if self._top&gt;=self._size-1:
            print(&quot;stack full&quot;)
        else:
            self._top += 1
            self._data[self._top] = item

    def pop(self):
        if self.isempty():
            print(&quot;stack empty&quot;)
            return None
        else:
            top = self._data[self._top]
            self._top -= 1
            return top
</code></pre>

<ul>
<li>也可以用链表实现（链式栈）：入栈，出栈时间复杂度都是O（1）。<br/>
```python<br/>
class Node(object):<br/>
&quot;&quot;&quot;定义链表的节点&quot;&quot;&quot;<br/>
def <strong>init</strong>(self, data):<br/>
    self.data_ = data<br/>
    self.next_ = None</li>
</ul>

<p>class Stack_imp_linkedlist(object):<br/>
    &#39;&#39;&#39;链表实现栈&#39;&#39;&#39;<br/>
    def <strong>init</strong>(self,):<br/>
        self.Link = Node(None)<br/>
        self.top = None<br/>
        self.len = 0</p>

<pre class="line-numbers"><code class="language-text">def push(self,item):
    p = Node(item)
    p.next_=self.Link.next_
    self.Link.next_=p
    self.top=p
    self.len+=1

def pop(self):
    if self.len&gt;0:
        data = self.top.data_
        self.Link.next_ = self.top.next_
        self.top = self.Link.next_
        self.len-=1
        return data
    else:
        print(&#39;Stack empty&#39;)
        return None
</code></pre>

<pre class="line-numbers"><code class="language-text"># 栈的应用
### 线程栈帧中的函数调用栈
每个线程都会分配一块独立的内存空间，这块空间被组织成`栈`这种结构，用来存储函数调用的是的临时变量。每执行一个函数，都会将其中的临时变量作为一个栈帧入栈，执行完之后，则会将这个函数对应的栈帧出栈。

### 表达式求值
如：3+4*5-2
编译器通过两个栈来实现表达式求值，一个栈存储操作数，一个存储操作符，

### 括号匹配
使用栈来检查表达式中的括号是否匹配，括号必须是成对出现的。而且不能交叉嵌套，

### 浏览器的前进后退
两个栈来实现浏览器的前进和后退功能，同样链表和数组也可以实现这个功能(因为链表和数组可以实现栈🙄)。





</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[队列：Queue]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15391808453198.html"/>
    <updated>2018-10-10T22:14:05+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15391808453198.html</id>
    <content type="html"><![CDATA[
<p>队列是先进先出（FIFO, First-In-First-Out）的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。</p>

<p>队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。</p>

<h1 id="toc_0">队列的特点</h1>

<ul>
<li>先入先出</li>
</ul>

<h1 id="toc_1">队列的简单实现</h1>

<h4 id="toc_2">1.顺序队列：数组实现</h4>

<pre class="line-numbers"><code class="language-python">class Queue(object):
    def __init__(self, init_size):
        self._data = [None] * init_size
        self._head = -1
        self._tail = -1
        self._size = init_size

    def add(self, item):
        if self._tail &gt;= self._size-1:
            print(&quot;queue full&quot;)
        else:
            self._tail += 1
            self._data[self._tail] = item

    def poll(self):
        if self._head &gt;= self._tail:
            print(&quot;queue empty&quot;)
        else:
            self._head += 1
            top = self._data[self._head]
            self._data[self._head] = None
            return top

    def foreach(self):
        rs = []
        while self._head &lt;= self._tail-1:
            top = self.poll()
            rs.append(top)
        return rs
</code></pre>

<h4 id="toc_3">2. 两个栈实现队列</h4>

<pre class="line-numbers"><code class="language-text">
</code></pre>

<h1 id="toc_4">队列的应用</h1>

<p>对于需要顺序执行的任务尝试用队列这种结构实现。</p>

<h1 id="toc_5">队列相关题目</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[堆：Heap]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392363328863.html"/>
    <updated>2018-10-11T13:38:52+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392363328863.html</id>
    <content type="html"><![CDATA[
<p>堆（英语：Heap）是计算机科学中的一种特别的<code>树状数据结构</code>。若是满足以下特性，即可称为堆：“给定堆中任意节点 P 和 C，若 P 是 C 的母节点，那么 P 的值会小于等于（或大于等于） C 的值”。若母节点的值恒小于等于子节点的值，此堆称为<code>最小堆</code>（英语：min heap）；反之，若母节点的值恒大于等于子节点的值，此堆称为<code>最大堆</code>（英语：max heap）。在堆中最顶端的那一个节点，称作根节点（英语：root node），根节点本身没有母节点（英语：parent node）。</p>

<p>堆始于 W. J. Williams 在 1964 年发表的<code>堆排序</code>（英语：heap sort），当时他提出了二叉堆树作为此算法的数据结构。堆在戴克斯特拉算法（英语：Dijkstra&#39;s algorithm）中亦为重要的关键。</p>

<p>在队列中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构「『优先级队列』」。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图：Graph]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392292553953.html"/>
    <updated>2018-10-11T11:40:55+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392292553953.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[哈希表：Hash]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392292427453.html"/>
    <updated>2018-10-11T11:40:42+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392292427453.html</id>
    <content type="html"><![CDATA[
<p>。。。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树：Tree]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392291769523.html"/>
    <updated>2018-10-11T11:39:36+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392291769523.html</id>
    <content type="html"><![CDATA[
<p>树是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>

<ul>
<li>每个节点有零个或多个子节点；</li>
<li>没有父节点的节点称为根节点；</li>
<li>每一个非根节点有且只有一个父节点；</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树；</li>
</ul>

<h1 id="toc_0">树的实现方式</h1>

<ul>
<li>二维数组：每个数组是树的一个节点node,每个node存储了当前节点的数据和它的父节点索引。</li>
<li>字典实现：</li>
</ul>

<h1 id="toc_1">树的应用</h1>

<ul>
<li>二叉树
<ul>
<li>AVL：平衡二叉树，当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</li>
<li>BST：排序二叉树，二叉查找树</li>
</ul></li>
<li>Huffman树：带权路径最短的二叉树称为哈夫曼树或最优二叉树</li>
<li>B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。</li>
<li>B+树：B树的优化</li>
<li>RBT红黑树：</li>
<li>堆Heap：二叉堆，斐波那契堆</li>
<li>Trie树：</li>
</ul>

<h1 id="toc_2">二叉树的python实现</h1>

<pre class="line-numbers"><code class="language-text">def 
</code></pre>

<h1 id="toc_3">二叉树的基本操作</h1>

<ul>
<li>层次遍历</li>
<li>之字形遍历</li>
<li>先序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>

<h1 id="toc_4">二叉树的相关题目</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[🐱 查找问题]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15393054098142.html"/>
    <updated>2018-10-12T08:50:09+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15393054098142.html</id>
    <content type="html"><![CDATA[
<p>最常见的查找就是<code>二分查找</code>，多数的查找问题的解决方案都是转化为选择合适的数据结构存储，再利用数据结构的特性来解决。比如：<code>Hash表</code>能够实现数据的直接定位，即O(1)的时间复杂度。<code>二叉排序树</code>，<code>红黑树</code>，<code>B树</code>，这些数据结构的设计就是为了解决数据搜索的问题。还有一些数据的查找如TopN借助于排序算法，</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二分查找]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15395253854404.html"/>
    <updated>2018-10-14T21:56:25+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15395253854404.html</id>
    <content type="html"><![CDATA[
<p>二分查找是一种查询算法，它的前提是：<code>数据必须有序</code>，基本思想是不断的将数据2分(即不断的去缩小一半的搜索范围)最终定位找到查询数据。</p>

<h1 id="toc_0">二分搜索的步骤：</h1>

<ol>
<li>用数组的中间元素比较key,相等则返回中间元素的索引</li>
<li>如果中间元素大于key,则在左侧继续查找</li>
<li>如果中间元素小于key,则在右侧继续查找</li>
<li>直到定位到单个元素为止</li>
</ol>

<h1 id="toc_1">二分查找的实现</h1>

<h4 id="toc_2">1、递归实现</h4>

<pre class="line-numbers"><code class="language-python">def binary_search(nums, start, end, key):
    &quot;&quot;&quot;递归实现&quot;&quot;&quot;
    if start &gt; end or nums==None:
        return None
    mid = start + int((end-start) / 2)
    if nums[mid] &gt; key:
        return binary_search(nums, start, mid-1, key)
    elif nums[mid] &lt; key:
        return binary_search(nums, mid+1, end, key)
    else:
        return mid
    return None
</code></pre>

<h4 id="toc_3">2、非递归实现</h4>

<pre class="line-numbers"><code class="language-python">def binary_search2(nums, start, end, key):
    &quot;&quot;&quot;非递归实现&quot;&quot;&quot;
    if start&gt;end or nums==None:
        return None
    while start &lt;= end:
        mid = start + int((end - start) / 2)
        if nums[mid] &gt; key:
            end = mid - 1
        elif nums[mid] &lt; key:
            start = mid + 1
        else:
            return mid
    return None
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[🐱 排序问题]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392700147620.html"/>
    <updated>2018-10-11T23:00:14+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392700147620.html</id>
    <content type="html"><![CDATA[
<p>在计算器科学与数学中，一个排序算法（英语：Sorting algorithm）是一种能将一串数据依照特定排序方式进行排列的一种算法。最常用到的排序方式是数值顺序以及字典顺序。有效的排序算法在一些算法（例如搜索算法与合并算法）中是重要的，如此这些算法才能得到正确解答。排序算法也用在处理文字数据以及产生人类可读的输出结果。基本上，排序算法的输出必须遵守下列两个原则：</p>

<ul>
<li>输出结果为递增序列（递增是针对所需的排序顺序而言）</li>
<li>输出结果是原输入的一种排列、或是重组<br/>
虽然排序算法是一个简单的问题，但是从计算器科学发展以来，在此问题上已经有大量的研究。举例而言，冒泡排序在1956年就已经被研究。虽然大部分人认为这是一个已经被解决的问题，有用的新算法仍在不断的被发明。<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">source：wiki</a></li>
</ul>

<h1 id="toc_0">排序算法的简单对比</h1>

<p><img src="media/15392697680749/15392699931786.jpg" alt="" style="width:1449px;"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[计数排序]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392716754828.html"/>
    <updated>2018-10-11T23:27:55+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392716754828.html</id>
    <content type="html"><![CDATA[
<p>计数排序（Counting sort）是一种稳定的线性时间排序算法。计数排序使用一个额外的数组 \({\displaystyle C}\) ，其中第i个元素是待排序数组 \({\displaystyle A}\)中值等于 \({\displaystyle i}\)的元素的个数。然后根据数组 \({\displaystyle C}\) 来将 \({\displaystyle A}\)中的元素排到正确的位置。</p>

<h1 id="toc_0">计数排序的时间复杂度</h1>

<p>O（n+k）</p>

<h1 id="toc_1">计数排序的优缺点</h1>

<ul>
<li>非比较排序，比任何比较排序的速度都快</li>
<li>不适合数据范围特别大的数据排序（数据量少，数据跨度大，会造成大量的空间浪费）</li>
</ul>

<h1 id="toc_2">计数排序的思想</h1>

<p>用数组的下标来表述要排序的数据，比如：数据3就给下标为3的位置+1，所以需要一个长度为数组中最大数值+1的一个数组来存储数据，步骤如下：<br/>
1、创建空间一个待排数组中最大值+1的数组numsk，这个数组的下标表示排序的数据，初始值为0，代表这个数字出现0次<br/>
2、遍历待排序数组nums，每个数num就给numsk中下表为num的数据+1,即数据num出现了一次。<br/>
3、遍历完之后数组numsk表示从0到K,每个数出现的次数。因为0-k是顺序的，则只需要遍历这个数组，用数组的下标*当前下标的数值(次数)，就得到了排序的结果。</p>

<h1 id="toc_3">计数排序的实现</h1>

<pre class="line-numbers"><code class="language-python">def countingSort(nums):
    &#39;&#39;&#39;计数排序&#39;&#39;&#39;
    k = max(nums) + 1
    numsk = [0] * k
    for num in nums:
        numsk[num] += 1
    numsn = []
    for i,num in enumerate(numsk):
        numsn.extend([i]*num)
    return numsn
</code></pre>

<h1 id="toc_4">案例解析：</h1>

<pre class="line-numbers"><code class="language-text">nums = [3,6,2,8,3,5,1,10]
k = 10+1
numsk = [0,0,0,0,0,0,0,0,0,0,0]
numsk = [0,1,1,2,0,0,1,0,1,0,1]
numsn = [1,2,3,3,6,8,10]
</code></pre>

<h1 id="toc_5">存在的问题：</h1>

<p>1、当数据的最小值不是从0开始的时候就会浪费大量的数组空间，比如：[90,92,94],只有3个数却要创建一个长度为95的数组<br/>
2、稳定性的问题，某个数出现了多次，<code>无法保证相对顺序</code>。<br/>
3、用数组的下标来表示一个数，就限制了需要排序的数据必须是<code>正整数</code>.</p>

<h1 id="toc_6">改进</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[希尔排序]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392716677172.html"/>
    <updated>2018-10-11T23:27:47+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392716677172.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"></h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[桶排序]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392715483846.html"/>
    <updated>2018-10-11T23:25:48+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392715483846.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"></h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[归并排序]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392715143262.html"/>
    <updated>2018-10-11T23:25:14+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392715143262.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"></h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快速排序]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392714966006.html"/>
    <updated>2018-10-11T23:24:56+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392714966006.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"></h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[冒泡排序]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392714719077.html"/>
    <updated>2018-10-11T23:24:31+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392714719077.html</id>
    <content type="html"><![CDATA[
<p>冒泡排序（英语：Bubble Sort）是一种简单的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p>

<h1 id="toc_0">冒泡排序的复杂度：</h1>

<p>最坏时间复杂度：\({\displaystyle O(n^{2})}\)<br/>
最优时间复杂度：\({\displaystyle O(n)}\)<br/>
平均时间复杂度：\({\displaystyle O(n^{2})}\)<br/>
最坏空间复杂度：总共\({\displaystyle O(n)}\)，需要辅助空间 \({\displaystyle O(1)}\)</p>

<h1 id="toc_1">冒泡排序的过程</h1>

<p><img src="https://zh.wikipedia.org/wiki/%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F#/media/File:Bubble_sort_animation.gif" alt=""/></p>

<h1 id="toc_2">冒泡排序的特点：</h1>

<ul>
<li>每次把待排序列的最大值放到最后</li>
<li>稳定排序：(元素相同的时候不交换顺序)<br/>
# 冒泡排序的实现：<br/>
```python<br/>
def bubble_sort(nums):<br/>
&#39;&#39;&#39;冒泡排序&#39;&#39;&#39;<br/>
if len(nums)&lt;=1 or nums==None:<br/>
    return nums<br/>
for i,num in enumerate(nums):<br/>
    for j in range(0,len(nums)-i-1):<br/>
        if nums[j]&gt;nums[j+1]:<br/>
            nums[j],nums[j+1] = nums[j+1],nums[j]<br/>
return nums</li>
</ul>

<p>if <strong>name</strong> == &#39;__main__&#39;:<br/>
    nums = [6,3,4,2,1,5,7]<br/>
    bubble_sort(nums)<br/>
    print(nums)</p>

<pre class="line-numbers"><code class="language-text">
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[插入排序]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392697680749.html"/>
    <updated>2018-10-11T22:56:08+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392697680749.html</id>
    <content type="html"><![CDATA[
<p>插入排序是一种直观的排序算法，通过为未排序元素与有序元素比较找到正确的位置构建新的有序序列来最终得到一个有序序列，它只需使用O(1)的额外空间，但是每个元素都要跟有序元素进行比较，时间复杂度是O(n<sup>2)</sup></p>

<h1 id="toc_0">插入排序的复杂度：</h1>

<p>最坏时间复杂度：\({\displaystyle O(n^{2})}\)<br/>
最优时间复杂度：\({\displaystyle O(n)}\)<br/>
平均时间复杂度：\({\displaystyle O(n^{2})}\)<br/>
最坏空间复杂度：\({\displaystyle O(n)}\)<br/>
需要辅助空间：\({\displaystyle O(1)}\)</p>

<h1 id="toc_1">插入排序的过程</h1>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt=""/></p>

<h1 id="toc_2">插入排序的实现</h1>

<pre class="line-numbers"><code class="language-python">def insert_sort(nums):
    &#39;&#39;&#39;插入排序&#39;&#39;&#39;
    if len(nums) &lt;= 1 or nums == None:
        return nums
    for i in range(1,len(nums)):
        for j in range(i, 0, -1):
            if nums[j] &lt; nums[j-1]:
                nums[j-1],nums[j] = nums[j],nums[j-1]
    return nums
if __name__ == &#39;__main__&#39;:
    nums = [6, 3, 2, 4, 1]
    print(insert_sort(nums))
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[选择排序]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15391804641073.html"/>
    <updated>2018-10-10T22:07:44+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15391804641073.html</id>
    <content type="html"><![CDATA[
<p><strong>选择排序</strong>（Selection sort）是一种简单直观的排序算法。它的工作原理如下。<br/>
1、首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，<br/>
2、然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。<br/>
3、循环第二步，直到所有元素均排序完毕。</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif" alt=""/></p>

<h1 id="toc_0">选择排序的特点：</h1>

<p>选择排序的主要优点与数据移动有关。如果某个元素位于正确的最终位置上，则它不会被移动。选择排序每次交换一对元素，它们当中至少有一个将被移到其最终位置上，因此对 \({\displaystyle n}\) 个元素的表进行排序总共进行至多\({\displaystyle n-1}\)次交换。在所有的完全依靠交换去移动元素的排序方法中，选择排序属于非常好的一种。</p>

<h1 id="toc_1">选择排序的实现</h1>

<pre class="line-numbers"><code class="language-python">def select_sort(nums):
    &#39;&#39;&#39;选择排序：&#39;&#39;&#39;
    if nums==None or len(nums)&lt;=1:
        return nums
    for i in range(len(nums)):
        min_index=i
        for j in range(i+1,len(nums)):
            if nums[j]&lt;nums[min_index]:
                min_index = j
        if min_index!=i:
            nums[i],nums[min_index] = nums[min_index],nums[i]
        print(&quot;i:%s\t min:%s\t nums:%s&quot; % (i,min_index,nums,))

if __name__ == &#39;__main__&#39;:
    nums = [17, 23, 20, 14, 12, 25, 1, 20, 81, 14, 11, 12]
    select_sort(nums)
</code></pre>

]]></content>
  </entry>
  
</feed>
