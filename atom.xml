<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[不以刷题为目的的面试不是个好程序员]]></title>
  <link href="http://atlasbl.cn/coding_for_interview/atom.xml" rel="self"/>
  <link href="http://atlasbl.cn/coding_for_interview/"/>
  <updated>2019-01-31T12:04:13+08:00</updated>
  <id>http://atlasbl.cn/coding_for_interview/</id>
  <author>
    <name><![CDATA[]]></name>
    
  </author>
  <generator uri="http://www.mweb.im">MWeb</generator>

  
  <entry>
    <title type="html"><![CDATA[数组：Array]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15391804069666.html"/>
    <updated>2018-10-10T22:06:46+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15391804069666.html</id>
    <content type="html"><![CDATA[
<p>在计算器科学中，数组数据结构（英语：array data structure），简称数组（英语：Array），是由相同类型的元素（element）的集合所组成的数据结构，「分配一块连续的内存来存储」。利用元素的索引（index）可以计算出该元素对应的存储地址。</p>

<p>最简单的数据结构类型是一维数组。例如，索引为0到9的32位整数数组，可作为在存储器地址2000，2004，2008，...2036中，存储10个变量，因此索引为i的元素即在存储器中的2000+4×i地址。数组第一个元素的存储器地址称为第一地址或基础地址。</p>

<h2 id="toc_0">数组的特点</h2>

<ul>
<li>连续的内存</li>
<li>同一类型</li>
<li>相同大小</li>
<li>随机读取</li>
<li>插入删除耗时</li>
<li>初始化必须知道大小</li>
<li>扩容消耗时间，空间</li>
</ul>

<h2 id="toc_1">数组应用</h2>

<ul>
<li>实现List：List这种数据结构就是通过数组实现的</li>
<li>实现String：字符串这种数据结构就是通过字符数组实现的</li>
<li>实现：队列，堆，树，栈。</li>
</ul>

<h2 id="toc_2">数组相关的题目</h2>

<p><a href="15392386512557.html">两数之和</a></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[链表：LinkedList]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15391807987921.html"/>
    <updated>2018-10-10T22:13:18+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15391807987921.html</id>
    <content type="html"><![CDATA[
<p>链表（Linked list）是一种常见的基础数据结构，是一种线性表，但是并不会按线性的顺序存储数据，而是在每一个节点里存到下一个节点的指针(Pointer)。由于不必须按顺序存储，链表在插入的时候可以达到O(1)的复杂度，比另一种线性表顺序表快得多，但是查找一个节点或者访问特定编号的节点则需要O(n)的时间，而顺序表相应的时间复杂度分别是O(logn)和O(1)。</p>

<p>使用链表结构可以克服数组链表需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间，实现灵活的内存动态管理。但是链表失去了数组随机读取的优点，同时链表由于增加了结点的指针域，空间开销比较大。</p>

<h1 id="toc_0">链表的特点</h1>

<ul>
<li>不使用连续的内存</li>
<li>只能顺序访问，不能随机读取</li>
<li>插入，删除简单，查找慢</li>
<li>动态扩展</li>
</ul>

<h1 id="toc_1">常见链表</h1>

<ul>
<li>单向链表</li>
<li>双向链表</li>
<li>循环链表</li>
</ul>

<h1 id="toc_2">链表的实现</h1>

<p>Python List实现链表：</p>

<pre class="line-numbers"><code class="language-python">class Node(object):
    &quot;&quot;&quot;定义链表的节点&quot;&quot;&quot;
    def __init__(self, data):
        self._data = data
        self._next = None

    def get_data(self):
        return self._data

    def get_next(self):
        return self._next

    def set_data(self, data):
        self._data = data

    def set_next(self, next):
        self._next = next

class LinkedList(object):
    def __init__(self):
        self._head = Node(None)
        self._tail = Node(None)
        self._head.set_next(self._tail)
        self._size = 0
        
    def add(self, data):
        &quot;&quot;&quot;头插法：新加入的元素永远在head._next&quot;&quot;&quot;
        node = Node(data)
        node.set_next(self._head.get_next())
        self._head.set_next(node)
        self._size += 1
        
    def remove(self, data):
        &quot;&quot;&quot;删除节点&quot;&quot;&quot;
        prev = self._head
        while prev.get_next() is not self._tail:
            cur = prev.get_next()
            if cur.get_data() == data:
                prev.set_next(cur.get_next())
        self._size -=1
        
    def size(self):
        return self._size
        
    def is_exist(self, data):
        &quot;&quot;&quot;查询某值是否在链表&quot;&quot;&quot;
        if any([self._head.get_next() == self._tail, data == None]):
            return False
        cur = self._head.get_next()
        while cur is not self._tail:
            if cur.get_data == data:
                return True
            else:
                return False
                
    def is_empty(self):
        &quot;&quot;&quot;判断是否为空&quot;&quot;&quot;
        return self._head.get_next() == self._tail
        
    def foreach(self):
        if self._head.get_next() == self._tail:
            return None
        data = []
        cur = self._head.get_next()
        while cur is not self._tail:
            data.append(cur.get_data())
            cur = cur.get_next()
        return data
</code></pre>

<p>因为是自定义实现，使用了固定长度的List来实现，链表的重要操作难度是在删除和添加节点上，</p>

<p><strong>⚠️注意</strong>：<code>Head指针永远不变，是链表的开始</code>，不要直接使用head指针直接去进行指针移动，这样就无法返回操作后的链表了。</p>

<h1 id="toc_3">链表相关的题目</h1>

<p>全部来源于<a href="https://leetcode-cn.com/">Leetcode</a>中文网</p>

<h4 id="toc_4">简单:</h4>

<p><a href="">『删除链表中的节点』</a>,<a href="">『删除链表的倒数第N个节点』</a>,<a href="">『反转链表』</a>,<a href="">『合并两个有序链表』</a>,<a href="">『回文链表』</a>,<a href="">『环形链表』</a></p>

<h4 id="toc_5">中等</h4>

<p>``</p>

<h4 id="toc_6">困难</h4>

<p>``</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[栈：Stack]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392291360952.html"/>
    <updated>2018-10-11T11:38:56+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392291360952.html</id>
    <content type="html"><![CDATA[
<p>栈（英语：stack）又称为栈或堆叠，是计算机科学中一种特殊的串列形式的抽象数据类型，其特殊之处在于只能允许在链表或数组的一端（称为堆栈顶端指针，英语：top）进行加入数据（英语：push）和输出数据（英语：pop）的运算。另外栈也可以用一维数组或链表的形式来完成。堆栈的另外一个相对的操作方式称为队列。</p>

<p>由于堆栈数据结构只允许在一端进行操作，因而按照后进先出（LIFO, Last In First Out）的原理运作</p>

<h1 id="toc_0">栈的操作</h1>

<p>堆栈数据结构使用两种基本操作：推入（压栈，push）和弹出（弹栈，pop）：</p>

<ul>
<li>推入：将数据放入堆栈的顶端（数组形式或串列形式），堆栈顶端top指针加一。</li>
<li>弹出：将顶端数据数据输出（回传），堆栈顶端数据减一。</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[队列：Queue]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15391808453198.html"/>
    <updated>2018-10-10T22:14:05+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15391808453198.html</id>
    <content type="html"><![CDATA[
<p>队列是先进先出（FIFO, First-In-First-Out）的线性表。在具体应用中通常用链表或者数组来实现。队列只允许在后端（称为rear）进行插入操作，在前端（称为front）进行删除操作。</p>

<p>队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。</p>

<h1 id="toc_0">队列的特点</h1>

<ul>
<li>先入先出</li>
</ul>

<h1 id="toc_1">队列的应用</h1>

<p>对于需要顺序执行的任务尝试用队列这种结构实现。</p>

<h1 id="toc_2">队列的简单实现</h1>

<h4 id="toc_3">1. Python List实现固定长度的队列,同样的方式可以实现双端队列</h4>

<pre class="line-numbers"><code class="language-python">class Queue(object):
    def __init__(self, init_size):
        self._data = [None] * init_size
        self._head = -1
        self._tail = -1
        self._size = init_size

    def add(self, item):
        if self._tail &gt;= self._size-1:
            print(&quot;queue full&quot;)
        else:
            self._tail += 1
            self._data[self._tail] = item

    def poll(self):
        if self._head &gt;= self._tail:
            print(&quot;queue empty&quot;)
        else:
            self._head += 1
            top = self._data[self._head]
            self._data[self._head] = None
            return top

    def foreach(self):
        rs = []
        while self._head &lt;= self._tail-1:
            top = self.poll()
            rs.append(top)
        return rs
</code></pre>

<h4 id="toc_4">2. 两个栈实现队列</h4>

<pre class="line-numbers"><code class="language-text">
</code></pre>

<h1 id="toc_5">队列相关题目</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[堆：Heap]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392363328863.html"/>
    <updated>2018-10-11T13:38:52+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392363328863.html</id>
    <content type="html"><![CDATA[
<p>堆（英语：Heap）是计算机科学中的一种特别的树状数据结构。若是满足以下特性，即可称为堆：“给定堆中任意节点 P 和 C，若 P 是 C 的母节点，那么 P 的值会小于等于（或大于等于） C 的值”。若母节点的值恒小于等于子节点的值，此堆称为最小堆（英语：min heap）；反之，若母节点的值恒大于等于子节点的值，此堆称为最大堆（英语：max heap）。在堆中最顶端的那一个节点，称作根节点（英语：root node），根节点本身没有母节点（英语：parent node）。</p>

<p>堆始于 W. J. Williams 在 1964 年发表的堆排序（英语：heap sort），当时他提出了二叉堆树作为此算法的数据结构。堆在戴克斯特拉算法（英语：Dijkstra&#39;s algorithm）中亦为重要的关键。</p>

<p>在队列中，调度程序反复提取队列中第一个作业并运行，因为实际情况中某些时间较短的任务将等待很长时间才能结束，或者某些不短小，但具有重要性的作业，同样应当具有优先权。堆即为解决此类问题设计的一种数据结构「『优先级队列』」。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[图：Graph]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392292553953.html"/>
    <updated>2018-10-11T11:40:55+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392292553953.html</id>
    <content type="html"><![CDATA[

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[哈希表：Hash]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392292427453.html"/>
    <updated>2018-10-11T11:40:42+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392292427453.html</id>
    <content type="html"><![CDATA[
<p>。。。</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[树：Tree]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392291769523.html"/>
    <updated>2018-10-11T11:39:36+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392291769523.html</id>
    <content type="html"><![CDATA[
<p>树是一种抽象数据类型（ADT）或是实现这种抽象数据类型的数据结构，用来模拟具有树状结构性质的数据集合。它是由n（n&gt;0）个有限节点组成一个具有层次关系的集合。把它叫做“树”是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p>

<ul>
<li>每个节点有零个或多个子节点；</li>
<li>没有父节点的节点称为根节点；</li>
<li>每一个非根节点有且只有一个父节点；</li>
<li>除了根节点外，每个子节点可以分为多个不相交的子树；</li>
</ul>

<h1 id="toc_0">树的实现方式</h1>

<ul>
<li>二维数组：每个数组是树的一个节点node,每个node存储了当前节点的数据和它的父节点索引。</li>
<li>字典实现：</li>
</ul>

<h1 id="toc_1">树的应用</h1>

<ul>
<li>二叉树
<ul>
<li>AVL：平衡二叉树，当且仅当任何节点的两棵子树的高度差不大于1的二叉树；</li>
<li>BST：排序二叉树，二叉查找树</li>
</ul></li>
<li>Huffman树：带权路径最短的二叉树称为哈夫曼树或最优二叉树</li>
<li>B树：一种对读写操作进行优化的自平衡的二叉查找树，能够保持数据有序，拥有多于两个子树。</li>
<li>B+树：B树的优化</li>
<li>RBT红黑树：</li>
<li>堆Heap：二叉堆，斐波那契堆</li>
<li>Trie树：</li>
</ul>

<h1 id="toc_2">二叉树的python实现</h1>

<pre class="line-numbers"><code class="language-text">def 
</code></pre>

<h1 id="toc_3">二叉树的基本操作</h1>

<ul>
<li>层次遍历</li>
<li>之字形遍历</li>
<li>先序遍历</li>
<li>中序遍历</li>
<li>后序遍历</li>
</ul>

<h1 id="toc_4">二叉树的相关题目</h1>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[查找问题]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15393054098142.html"/>
    <updated>2018-10-12T08:50:09+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15393054098142.html</id>
    <content type="html"><![CDATA[
<p>最常见的查找就是<code>二分查找</code>，多数的查找问题的解决方案都是转化为选择合适的数据结构存储，再利用数据结构的特性来解决。比如：<code>Hash表</code>能够实现数据的直接定位，即O(1)的时间复杂度。<code>二叉排序树</code>，<code>红黑树</code>，<code>B树</code>，这些数据结构的设计就是为了解决数据搜索的问题。还有一些数据的查找如TopN借助于排序算法，</p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[二分查找]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15395253854404.html"/>
    <updated>2018-10-14T21:56:25+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15395253854404.html</id>
    <content type="html"><![CDATA[
<p>二分查找是一种查询算法，它的前提是：<code>数据必须有序</code>，基本思想是不断的将数据2分(即不断的去缩小一半的搜索范围)最终定位找到查询数据。</p>

<h1 id="toc_0">二分搜索的步骤：</h1>

<ol>
<li>用数组的中间元素比较key,相等则返回中间元素的索引</li>
<li>如果中间元素大于key,则在左侧继续查找</li>
<li>如果中间元素小于key,则在右侧继续查找</li>
<li>直到定位到单个元素为止</li>
</ol>

<h1 id="toc_1">二分查找的实现</h1>

<h4 id="toc_2">1、递归实现</h4>

<pre class="line-numbers"><code class="language-python">def binary_search(nums, start, end, key):
    &quot;&quot;&quot;递归实现&quot;&quot;&quot;
    if start &gt; end:
        return -1
    mid = start + (start - end) / 2
    if nums[mid] &gt; key:
        return binary_search(nums, start, mid-1, key)
    elif nums[mid] &lt; key:
        return binary_search(nums, mid+1, end, key)
    else:
        return mid
</code></pre>

<h4 id="toc_3">2、非递归实现</h4>

<pre class="line-numbers"><code class="language-python">def binary_search(nums, start, end, key):
    &quot;&quot;&quot;非递归实现&quot;&quot;&quot;
    while start&lt;=end:
        mid = start+(start-end)/2
        if nums[mid]&gt;key:
            end = mid-1
        elif nums[mid]&lt;key:
            start = mid+1
        else:
            return mid
    return -1
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[排序问题]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392700147620.html"/>
    <updated>2018-10-11T23:00:14+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392700147620.html</id>
    <content type="html"><![CDATA[
<p>在计算器科学与数学中，一个排序算法（英语：Sorting algorithm）是一种能将一串数据依照特定排序方式进行排列的一种算法。最常用到的排序方式是数值顺序以及字典顺序。有效的排序算法在一些算法（例如搜索算法与合并算法）中是重要的，如此这些算法才能得到正确解答。排序算法也用在处理文字数据以及产生人类可读的输出结果。基本上，排序算法的输出必须遵守下列两个原则：</p>

<ul>
<li>输出结果为递增序列（递增是针对所需的排序顺序而言）</li>
<li>输出结果是原输入的一种排列、或是重组<br/>
虽然排序算法是一个简单的问题，但是从计算器科学发展以来，在此问题上已经有大量的研究。举例而言，冒泡排序在1956年就已经被研究。虽然大部分人认为这是一个已经被解决的问题，有用的新算法仍在不断的被发明。<a href="https://zh.wikipedia.org/wiki/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95">source：wiki</a></li>
</ul>

<h1 id="toc_0">排序算法的简单对比</h1>

<p><img src="media/15392697680749/15392699931786.jpg" alt="" style="width:1449px;"/></p>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[计数排序]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392716754828.html"/>
    <updated>2018-10-11T23:27:55+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392716754828.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"></h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[希尔排序]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392716677172.html"/>
    <updated>2018-10-11T23:27:47+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392716677172.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"></h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[桶排序]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392715483846.html"/>
    <updated>2018-10-11T23:25:48+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392715483846.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"></h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[归并排序]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392715143262.html"/>
    <updated>2018-10-11T23:25:14+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392715143262.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"></h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[快速排序]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392714966006.html"/>
    <updated>2018-10-11T23:24:56+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392714966006.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"></h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[冒泡排序]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392714719077.html"/>
    <updated>2018-10-11T23:24:31+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392714719077.html</id>
    <content type="html"><![CDATA[
<h2 id="toc_0"></h2>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[插入排序]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15392697680749.html"/>
    <updated>2018-10-11T22:56:08+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15392697680749.html</id>
    <content type="html"><![CDATA[
<p>插入排序是一种直观的排序算法，通过不管的构建将为排序元素与有序元素比较找到正确的位置构建新的有序序列来最终得到一个有序序列，它只需使用O(1)的额外空间，但是每个元素都要跟有序元素进行比较，时间复杂度是O(n<sup>2)</sup></p>

<h1 id="toc_0">插入排序的复杂度：</h1>

<p>最坏时间复杂度 \({\displaystyle O(n^{2})}\)<br/>
最优时间复杂度 \({\displaystyle O(n)}\)<br/>
平均时间复杂度 \({\displaystyle O(n^{2})}\)<br/>
最坏空间复杂度 \({\displaystyle O(n)}\)<br/>
需要辅助空间     \({\displaystyle O(1)}\)</p>

<h1 id="toc_1">插入排序的过程</h1>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/0/0f/Insertion-sort-example-300px.gif" alt=""/></p>

<h1 id="toc_2">插入排序的实现</h1>

<pre class="line-numbers"><code class="language-python">def insert_sort(nums):
    if len(nums) &lt;= 1 or nums == None:
        return nums
    for i in range(1,len(nums)):
        for j in range(i, 0, -1):
            if nums[j] &lt; nums[j-1]:
                nums[j-1],nums[j] = nums[j],nums[j-1]
            else:
                break
    return nums
</code></pre>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Markdown语法]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15391839924703.html"/>
    <updated>2018-10-10T23:06:32+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15391839924703.html</id>
    <content type="html"><![CDATA[
<p>我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，<strong>Cmd Markdown</strong> 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：</p>

<blockquote>
<ul>
<li>整理知识，学习笔记</li>
<li>发布日记，杂文，所见所想</li>
<li>撰写发布技术文稿（代码支持）</li>
<li>撰写发布学术论文（LaTeX 公式支持）</li>
</ul>
</blockquote>

<p><img src="https://www.zybuluo.com/static/img/logo.png" alt="cmd-markdown-logo"/></p>

<p>除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：</p>

<h3 id="toc_0"><a href="https://www.zybuluo.com/cmd/">Windows/Mac/Linux 全平台客户端</a></h3>

<blockquote>
<p>请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class="icon-file"></i> <strong>新文稿</strong> 或者使用快捷键 <code>Ctrl+Alt+N</code>。</p>
</blockquote>

<h2 id="toc_1">什么是 Markdown</h2>

<p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p>

<h3 id="toc_2">1. 制作一份待办事宜 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-%E5%BE%85%E5%8A%9E%E4%BA%8B%E5%AE%9C-todo-%E5%88%97%E8%A1%A8">Todo 列表</a></h3>

<ul>
<li class="task-list-item"><input disabled="disabled" type="checkbox" /> 支持以 PDF 格式导出文稿</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" /> 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 新增 Todo 列表功能</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 修复 LaTex 公式渲染问题</li>
<li class="task-list-item"><input disabled="disabled" type="checkbox" checked /> 新增 LaTex 公式编号功能</li>
</ul>

<h3 id="toc_3">2. 书写一个质能守恒公式<sup id="fnref1"><a href="#fn1" rel="footnote">1</a></sup></h3>

<p>\[E=mc^2\]</p>

<h3 id="toc_4">3. 高亮一段代码<sup id="fnref2"><a href="#fn2" rel="footnote">2</a></sup></h3>

<pre class="line-numbers"><code class="language-python">@requires_authorization
class SomeClass:
    pass

if __name__ == &#39;__main__&#39;:
    # A comment
    print &#39;hello world&#39;
</code></pre>

<pre class="line-numbers"><code class="language-python">def swap_bin(num, i, j):
    &quot;&quot;&quot;x&amp;1 表示最后一位是什么
    (0b0000110 &gt;&gt; 1) &amp;1 # 1
    (0b0000110 &gt;&gt; 2) &amp;1 # 1
    (0b0000110 &gt;&gt; 3) &amp;1 # 0

    (1 &lt;&lt; num) | (1 &lt;&lt; j)表示交换i,j的值
    &quot;&quot;&quot;
    if (num &gt;&gt; i) &amp; 1 != (num &gt;&gt; j) &amp; j:
        num = num ^ (1 &lt;&lt; num) | (1 &lt;&lt; j)

    return num
</code></pre>

<h3 id="toc_5">4. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-%E6%B5%81%E7%A8%8B%E5%9B%BE">流程图</a></h3>

<pre class="line-numbers"><code class="language-mermaid">graph TD;
  A--&gt;B;
  A--&gt;C;
  B--&gt;D;
  C--&gt;D;
</code></pre>

<h3 id="toc_6">5. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-%E5%BA%8F%E5%88%97%E5%9B%BE">序列图</a></h3>

<pre class="line-numbers"><code class="language-mermaid">sequenceDiagram
    participant Alice
    participant Bob
    Alice-&gt;John: Hello John, how are you?
    loop Healthcheck
        John-&gt;John: Fight against hypochondria
    end
    Note right of John: Rational thoughts &lt;br&gt;prevail...
    John--&gt;Alice: Great!
    John-&gt;Bob: How about you?
    Bob--&gt;John: Jolly good!
</code></pre>

<h3 id="toc_7">6. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#9-%E7%94%98%E7%89%B9%E5%9B%BE">甘特图</a></h3>

<pre class="line-numbers"><code class="language-mermaid">gantt
    title 项目开发流程
    section 项目确定
        需求分析       :a1, 2016-06-22, 3d
        可行性报告     :after a1, 5d
        概念验证       : 5d
    section 项目实施
        概要设计      :2016-07-05  , 5d
        详细设计      :2016-07-08, 10d
        编码          :2016-07-15, 10d
        测试          :2016-07-22, 5d
    section 发布验收
        发布: 2d
        验收: 3d
</code></pre>

<h3 id="toc_8">7. 绘制表格</h3>

<table>
<thead>
<tr>
<th>项目</th>
<th style="text-align: right">价格</th>
<th style="text-align: center">数量</th>
</tr>
</thead>

<tbody>
<tr>
<td>计算机</td>
<td style="text-align: right">$1600</td>
<td style="text-align: center">5</td>
</tr>
<tr>
<td>手机</td>
<td style="text-align: right">$12</td>
<td style="text-align: center">12</td>
</tr>
<tr>
<td>管线</td>
<td style="text-align: right">$1</td>
<td style="text-align: center">234</td>
</tr>
</tbody>
</table>

<h3 id="toc_9">8. 更详细语法说明</h3>

<p>想要查看更详细的语法说明，可以参考我们准备的 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown">Cmd Markdown 简明语法手册</a>，进阶用户可以参考 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-%E9%AB%98%E9%98%B6%E8%AF%AD%E6%B3%95%E6%89%8B%E5%86%8C">Cmd Markdown 高阶语法手册</a> 了解更多高级功能。</p>

<p>总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p>

<hr/>

<h2 id="toc_10">什么是 Cmd Markdown</h2>

<p>您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 <strong>编辑/发布/阅读</strong> Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。</p>

<h3 id="toc_11">1. 实时同步预览</h3>

<p>我们将 Cmd Markdown 的主界面一分为二，左边为<strong>编辑区</strong>，右边为<strong>预览区</strong>，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！</p>

<h3 id="toc_12">2. 编辑工具栏</h3>

<p>也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 <strong>编辑区</strong> 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。</p>

<p><img src="https://www.zybuluo.com/static/img/toolbar-editor.png" alt="tool-editor"/></p>

<h3 id="toc_13">3. 编辑模式</h3>

<p>完全心无旁骛的方式编辑文字：点击 <strong>编辑工具栏</strong> 最右侧的拉伸按钮或者按下 <code>Ctrl + M</code>，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！</p>

<h3 id="toc_14">4. 实时的云端文稿</h3>

<p>为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 <strong>编辑工具栏</strong> 的最右侧提示 <code>已保存</code> 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。</p>

<h3 id="toc_15">5. 离线模式</h3>

<p>在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。</p>

<h3 id="toc_16">6. 管理工具栏</h3>

<p>为了便于管理您的文稿，在 <strong>预览区</strong> 的顶部放置了如下所示的 <strong>管理工具栏</strong>：</p>

<p><img src="https://www.zybuluo.com/static/img/toolbar-manager.jpg" alt="tool-manager"/></p>

<p>通过管理工具栏可以：</p>

<p><i class="icon-share"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享<br/>
<i class="icon-file"></i> 新建：开始撰写一篇新的文稿<br/>
<i class="icon-trash"></i> 删除：删除当前的文稿<br/>
<i class="icon-cloud"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地<br/>
<i class="icon-reorder"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作<br/>
<i class="icon-pencil"></i> 模式：切换 普通/Vim/Emacs 编辑模式</p>

<h3 id="toc_17">7. 阅读工具栏</h3>

<p><img src="https://www.zybuluo.com/static/img/toolbar-reader.jpg" alt="tool-manager"/></p>

<p>通过 <strong>预览区</strong> 右上角的 <strong>阅读工具栏</strong>，可以查看当前文稿的目录并增强阅读体验。</p>

<p>工具栏上的五个图标依次为：</p>

<p><i class="icon-list"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落<br/>
<i class="icon-chevron-sign-left"></i> 视图：互换左边编辑区和右边预览区的位置<br/>
<i class="icon-adjust"></i> 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br/>
<i class="icon-desktop"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br/>
<i class="icon-fullscreen"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</p>

<h3 id="toc_18">8. 阅读模式</h3>

<p>在 <strong>阅读工具栏</strong> 点击 <i class="icon-desktop"></i> 或者按下 <code>Ctrl+Alt+M</code> 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。</p>

<h3 id="toc_19">9. 标签、分类和搜索</h3>

<p>在编辑区任意行首位置输入以下格式的文字可以标签当前文档：</p>

<p>标签： 未分类</p>

<p>标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：</p>

<p><img src="https://www.zybuluo.com/static/img/file-list.png" alt="file-list"/></p>

<h3 id="toc_20">10. 文稿发布和分享</h3>

<p>在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class="icon-share"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！</p>

<hr/>

<p>再一次感谢您花费时间阅读这份欢迎稿，点击 <i class="icon-file"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！</p>

<p>作者 <a href="http://weibo.com/ghosert">@ghosert</a><br/><br/>
2016 年 07月 07日<br/><br/>
[TOC]</p>

<div class="footnotes">
<hr/>
<ol>

<li id="fn1">
<p>支持 <strong>LaTeX</strong> 编辑显示支持，例如：\(\sum_{i=1}^n a_i=0\)， 访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference">MathJax</a> 参考更多使用方法。&nbsp;<a href="#fnref1" rev="footnote">&#8617;</a></p>
</li>

<li id="fn2">
<p>代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。&nbsp;<a href="#fnref2" rev="footnote">&#8617;</a></p>
</li>

</ol>
</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[选择排序]]></title>
    <link href="http://atlasbl.cn/coding_for_interview/15391804641073.html"/>
    <updated>2018-10-10T22:07:44+08:00</updated>
    <id>http://atlasbl.cn/coding_for_interview/15391804641073.html</id>
    <content type="html"><![CDATA[
<p><img src="https://upload.wikimedia.org/wikipedia/commons/b/b0/Selection_sort_animation.gif" alt=""/></p>

]]></content>
  </entry>
  
</feed>
